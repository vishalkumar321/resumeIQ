import PDFDocument from "pdfkit";

// Palette
const COLORS = {
    primary: "#4F46E5", // indigo-600
    dark: "#111827",    // gray-900
    muted: "#6B7280",   // gray-500
    green: "#16A34A",
    yellow: "#CA8A04",
    red: "#DC2626",
    orange: "#EA580C",
    sectionBg: "#F9FAFB", // gray-50
    border: "#E5E7EB",    // gray-200
};

const MARGIN = 50;
const FOOTER_H = 32;

function scoreColor(score) {
    if (score >= 75) return COLORS.green;
    if (score >= 50) return COLORS.yellow;
    return COLORS.red;
}

function scoreLabel(score) {
    if (score >= 75) return "Strong";
    if (score >= 50) return "Moderate";
    return "Needs Work";
}

/**
 * Streams a formatted PDF for the given report into the writable `stream`.
 * @param {object} report  — full report row from the DB
 * @param {object} stream  — Node writable (Express res)
 */
export const generateReportPDF = (report, stream) => {
    const doc = new PDFDocument({
        size: "A4",
        margins: { top: MARGIN, bottom: MARGIN + FOOTER_H, left: MARGIN, right: MARGIN },
        autoFirstPage: true,
        bufferPages: false,
    });

    doc.pipe(stream);

    const W = doc.page.width - MARGIN * 2; // usable width

    // ── Register footer handler FIRST so it fires for every page break ───────
    // IMPORTANT: after drawing the footer we reset doc.y to the top margin,
    // otherwise PDFKit's cursor stays below the page bottom and cascades
    // into an infinite series of blank pages.
    doc.on("pageAdded", () => {
        const pageH = doc.page.height;
        doc
            .rect(0, pageH - FOOTER_H, doc.page.width, FOOTER_H)
            .fill("#F9FAFB");
        doc
            .fillColor(COLORS.muted)
            .fontSize(8)
            .font("Helvetica")
            .text(
                "Generated by ResumeIQ · resumeiq.app",
                MARGIN,
                pageH - FOOTER_H + 10,
                { width: W, align: "center" }
            );
        // Reset cursor to the top content area so continued writing is correct
        doc.y = MARGIN;
    });

    // ── Header bar ────────────────────────────────────────────────────────────
    doc.rect(0, 0, doc.page.width, 70).fill(COLORS.primary);

    doc
        .fillColor("#FFFFFF")
        .fontSize(22)
        .font("Helvetica-Bold")
        .text("ResumeIQ", MARGIN, 22);

    doc
        .fontSize(10)
        .font("Helvetica")
        .text("AI-Powered Resume Analysis Report", MARGIN, 48);

    doc.y = 78;

    // ── Meta row ──────────────────────────────────────────────────────────────
    const isJD = report.analysis_type === "jd";
    const label = isJD ? "JD Match Analysis" : `Role: ${report.role}`;
    const date = new Date(report.created_at).toLocaleDateString("en-IN", {
        day: "numeric", month: "long", year: "numeric",
    });

    doc
        .fillColor(COLORS.muted)
        .fontSize(10)
        .font("Helvetica")
        .text(`${label}   ·   Generated on ${date}`, MARGIN, doc.y, { width: W });

    doc.moveDown(0.6);
    doc.moveTo(MARGIN, doc.y).lineTo(MARGIN + W, doc.y).strokeColor(COLORS.border).stroke();
    doc.moveDown(0.8);

    // ── Score section ─────────────────────────────────────────────────────────
    const scoreY = doc.y;
    const boxW = isJD ? W / 2 - 6 : W;

    // ATS Score box
    doc.roundedRect(MARGIN, scoreY, boxW, 72, 6).fillAndStroke(COLORS.sectionBg, COLORS.border);
    doc.fillColor(COLORS.muted).fontSize(8).font("Helvetica-Bold")
        .text("ATS SCORE", MARGIN + 12, scoreY + 10, { width: boxW - 20 });
    doc.fillColor(scoreColor(report.score)).fontSize(36).font("Helvetica-Bold")
        .text(String(report.score), MARGIN + 12, scoreY + 22, { width: 80 });
    doc.fillColor(COLORS.muted).fontSize(10).font("Helvetica")
        .text(`/ 100  —  ${scoreLabel(report.score)}`, MARGIN + 65, scoreY + 35);

    if (isJD && report.match_score != null) {
        const x2 = MARGIN + boxW + 12;
        doc.roundedRect(x2, scoreY, boxW, 72, 6).fillAndStroke(COLORS.sectionBg, COLORS.border);
        doc.fillColor(COLORS.muted).fontSize(8).font("Helvetica-Bold")
            .text("JD MATCH SCORE", x2 + 12, scoreY + 10, { width: boxW - 20 });
        doc.fillColor(scoreColor(report.match_score)).fontSize(36).font("Helvetica-Bold")
            .text(String(report.match_score), x2 + 12, scoreY + 22, { width: 80 });
        doc.fillColor(COLORS.muted).fontSize(10).font("Helvetica")
            .text(`/ 100  —  ${scoreLabel(report.match_score)}`, x2 + 65, scoreY + 35);
    }

    doc.y = scoreY + 82;
    doc.moveDown(1);

    // ── Missing Keywords (JD only) ─────────────────────────────────────────────
    const keywords = (report.missing_keywords || []).filter(k => k && k.trim());
    if (isJD && keywords.length > 0) {
        sectionHeader(doc, W, "Missing Keywords", COLORS.orange);
        doc.moveDown(0.4);

        let x = MARGIN, y = doc.y;
        const chipH = 18, chipPad = 10, gap = 6;

        keywords.forEach((kw) => {
            const tw = doc.widthOfString(kw, { fontSize: 9 }) + chipPad * 2;
            if (x + tw > MARGIN + W) { x = MARGIN; y += chipH + gap; }
            doc.roundedRect(x, y, tw, chipH, 3).fillAndStroke("#FFF7ED", "#FDBA74");
            doc.fillColor(COLORS.orange).fontSize(9).font("Helvetica")
                .text(kw, x + chipPad, y + 4, { width: tw - chipPad * 2, lineBreak: false });
            x += tw + gap;
        });

        doc.y = y + chipH + 12;
        doc.moveDown(0.8);
    }

    // ── Bullet sections ───────────────────────────────────────────────────────
    bulletSection(doc, W, "Strengths", report.strengths, "#F0FDF4", "#86EFAC", COLORS.green);
    bulletSection(doc, W, "Weaknesses", report.weaknesses, "#FEFCE8", "#FDE68A", COLORS.yellow);
    bulletSection(doc, W, "Suggestions", report.suggestions, "#EFF6FF", "#BFDBFE", "#1D4ED8");

    doc.end();
};

// ── Helpers ─────────────────────────────────────────────────────────────────

function contentBottom(doc) {
    return doc.page.height - doc.page.margins.bottom;
}

function sectionHeader(doc, W, title, color = COLORS.primary) {
    // Check if there's enough space for the header + at least one item
    if (doc.y + 60 > contentBottom(doc)) {
        doc.addPage();
    }
    doc
        .fillColor(color)
        .fontSize(13)
        .font("Helvetica-Bold")
        .text(title, MARGIN, doc.y, { width: W });
}

function bulletSection(doc, W, title, items, bgColor, borderColor, textColor) {
    // Filter out empty/null items so no blank boxes appear in the PDF
    const validItems = (items || []).filter(item => item && item.trim().length > 0);
    if (validItems.length === 0) return;

    sectionHeader(doc, W, title, textColor);
    doc.moveDown(0.4);

    validItems.forEach((item, i) => {
        const itemH = doc.heightOfString(item, { width: W - 30, fontSize: 10 }) + 18;

        // If this item won't fit on the current page, add a new page first
        if (doc.y + itemH > contentBottom(doc)) {
            doc.addPage();
        }

        const startY = doc.y;
        const isLast = i === validItems.length - 1;

        doc
            .roundedRect(MARGIN, startY, W, itemH - 4, 5)
            .fillAndStroke(bgColor, borderColor);

        doc
            .fillColor(textColor)
            .fontSize(10)
            .font("Helvetica-Bold")
            .text("•", MARGIN + 12, startY + 7, { lineBreak: false });

        doc
            .fillColor(COLORS.dark)
            .fontSize(10)
            .font("Helvetica")
            .text(item, MARGIN + 26, startY + 7, { width: W - 34 });

        doc.y = startY + itemH;
        if (!isLast) doc.moveDown(0.15);
    });

    doc.moveDown(0.8);
}
